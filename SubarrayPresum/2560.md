https://leetcode.com/problems/house-robber-iv/

# Python ðŸ

```python
class Solution:
    def minCapability(self, nums: List[int], k: int) -> int:
        l = 1
        r = max(nums)
        ans = 0
        while l <= r:
            m = (l + r) // 2
            if self.robber(nums, m) >= k:
                ans = m
                r = m - 1
            else:
                l = m + 1
        return ans

    def robber(self, nums: List[int], ability: int) -> int:
        lastLast = 1 if nums[0] <= ability else 0
        if len(nums) == 1:
            return lastLast
        last = 1 if nums[0] <= ability or nums[1] <= ability else 0
        ans = max(lastLast, last)
        for i in range(2, len(nums)):
            p1 = last
            p2 = 0
            if nums[i] <= ability:
                p2 = lastLast + 1
            cur = max(p1, p2)
            ans = max(ans, cur)
            lastLast = last
            last = cur
        return ans

```

# RustðŸ¦€ï¸
```rust
impl Solution {
    pub fn min_capability(nums: Vec<i32>, k: i32) -> i32 {
        let mut l = 1;
        let mut r = *nums.iter().max().unwrap();
        let mut ans = 0;

        while l <= r {
            let m = (l + r) / 2;
            if Solution::robber(&nums, m) >= k {
                ans = m;
                r = m - 1;
            } else {
                l = m + 1;
            }
        }
        ans
    }

    pub fn robber(nums: &Vec<i32>, ability: i32) -> i32 {
        let mut last_last = if nums[0] <= ability { 1 } else { 0 };

        if nums.len() == 1 {
            return last_last;
        }

        let mut last = if nums[0] <= ability || nums[1] <= ability { 1 } else { 0 };
        let mut ans = std::cmp::max(last_last, last);

        for i in 2..nums.len() {
            let p1 = last;
            let p2 = if nums[i] <= ability { last_last + 1 } else { 0 };
            let cur = std::cmp::max(p1, p2);
            ans = std::cmp::max(ans, cur);
            last_last = last;
            last = cur;
        }
        ans
    }
}


```
# C++ ðŸ¦
```cpp
#include <vector>
#include <algorithm>

class Solution {
public:
    int minCapability(std::vector<int>& nums, int k) {
        int l = 1;
        int r = *std::max_element(nums.begin(), nums.end());
        int ans = 0;

        while (l <= r) {
            int m = (l + r) / 2;
            if (robber(nums, m) >= k) {
                ans = m;
                r = m - 1;
            }
            else {
                l = m + 1;
            }
        }
        return ans;
    }

    int robber(std::vector<int>& nums, int ability) {
        int lastLast = nums[0] <= ability ? 1 : 0;

        if (nums.size() == 1) {
            return lastLast;
        }

        int last = nums[0] <= ability || nums[1] <= ability ? 1 : 0;
        int ans = std::max(lastLast, last);

        for (size_t i = 2; i < nums.size(); ++i) {
            int p1 = last;
            int p2 = 0;
            if (nums[i] <= ability) {
                p2 = lastLast + 1;
            }
            int cur = std::max(p1, p2);
            ans = std::max(ans, cur);
            lastLast = last;
            last = cur;
        }
        return ans;
    }
};


```

# ðŸ”
```c
#include <stdlib.h>

typedef struct {
    int *arr;
    int front;
    int back;
    int size;
    int capacity;
} deque_t;

void push_back(deque_t* q, int value) {
    if (q->size == q->capacity) {
        q->capacity *= 2;
        q->arr = (int*)realloc(q->arr, sizeof(int) * q->capacity);
    }
    q->arr[q->back] = value;
    q->back = (q->back + 1) % q->capacity;
    q->size++;
}

void pop_front(deque_t* q) {
    q->front = (q->front + 1) % q->capacity;
    q->size--;
}

void pop_back(deque_t* q) {
    q->back = (q->back - 1 + q->capacity) % q->capacity;
    q->size--;
}

int front(deque_t* q) {
    return q->arr[q->front];
}

int back(deque_t* q) {
    return q->arr[(q->back - 1 + q->capacity) % q->capacity];
}

int* maxSlidingWindow(int* nums, int numsSize, int w, int* returnSize) {
    *returnSize = numsSize - w + 1;
    int* res = (int*)malloc(sizeof(int) * (*returnSize));
    deque_t q;
    q.arr = (int*)malloc(sizeof(int) * numsSize);
    q.front = 0;
    q.back = 0;
    q.size = 0;
    q.capacity = numsSize;
    int idx = 0;

    for (int R = 0; R < numsSize; R++) {
        while (q.size != 0 && nums[back(&q)] <= nums[R]) {
            pop_back(&q);
        }
        push_back(&q, R);

        if (front(&q) == R - w) {
            pop_front(&q);
        }

        if (R >= w - 1) {
            res[idx] = nums[front(&q)];
            idx++;
        }
    }
    free(q.arr);
    return res;
}

```