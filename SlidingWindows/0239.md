```python
class Solution:
    def maxSlidingWindow(self, nums: List[int], w: int) -> List[int]:
        if nums is None or w < 1 or len(nums) < w:
            return None
        qmax = deque()
        res = [0] * (len(nums) - w + 1)
        idx = 0
        for R in range(len(nums)):
            while qmax and nums[qmax[-1]] <= nums[R]:
                qmax.pop()
            qmax.append(R)
            if qmax[0] == R - w:
                qmax.popleft()
            if R >= w - 1:
                res[idx] = nums[qmax[0]]
                idx += 1
        return res
```


```rust
use std::collections::VecDeque;

impl Solution {
    pub fn max_sliding_window(nums: Vec<i32>, k: i32) -> Vec<i32> {
        if nums.is_empty() || k < 1 || nums.len() < k as usize {
            return vec![];
        }
        let mut qmax: VecDeque<usize> = VecDeque::new();
        let mut res = vec![0; nums.len() - k as usize + 1];
        let mut idx = 0;
        for R in 0..nums.len() {
            while !qmax.is_empty() && nums[*qmax.back().unwrap()] <= nums[R] {
                qmax.pop_back();
            }
            qmax.push_back(R);
            if *qmax.front().unwrap() == R - k as usize {
                qmax.pop_front();
            }
            if R as i32 >= k - 1 {
                res[idx] = nums[*qmax.front().unwrap()];
                idx += 1;
            }
        }
        res
    }
}

```